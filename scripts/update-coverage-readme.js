/*
  Updates README.md coverage section between markers:
  <!-- COVERAGE-START --> ... <!-- COVERAGE-END -->
  using coverage/coverage-summary.json generated by Jest.
*/

const fs = require('fs');
const path = require('path');

const ROOT = process.cwd();
const SUMMARY_PATH = path.join(ROOT, 'coverage', 'coverage-summary.json');
const README_PATH = path.join(ROOT, 'README.md');
const BADGES_DIR = path.join(ROOT, 'badges');
const BADGE_PATH = path.join(BADGES_DIR, 'coverage.json');

function readCoverage() {
  if (!fs.existsSync(SUMMARY_PATH)) {
    throw new Error(`Coverage summary not found at ${SUMMARY_PATH}. Ensure Jest ran with json-summary reporter.`);
  }
  const json = JSON.parse(fs.readFileSync(SUMMARY_PATH, 'utf8'));
  const total = json.total || {};
  const pct = (k) => (total[k] && typeof total[k].pct === 'number' ? total[k].pct.toFixed(2) : '0.00');
  return {
    statements: pct('statements'),
    branches: pct('branches'),
    functions: pct('functions'),
    lines: pct('lines'),
  };
}

function updateReadme(coverage) {
  if (!fs.existsSync(README_PATH)) {
    throw new Error('README.md not found');
  }
  const startMarker = '<!-- COVERAGE-START -->';
  const endMarker = '<!-- COVERAGE-END -->';
  const readme = fs.readFileSync(README_PATH, 'utf8');

  const block = [
    startMarker,
    'Coverage from latest test run:',
    '',
    `- Statements: ${coverage.statements}%`,
    `- Branches: ${coverage.branches}%`,
    `- Functions: ${coverage.functions}%`,
    `- Lines: ${coverage.lines}%`,
    endMarker,
  ].join('\n');

  let newReadme;
  if (readme.includes(startMarker) && readme.includes(endMarker)) {
    const start = readme.indexOf(startMarker);
    const end = readme.indexOf(endMarker) + endMarker.length;
    newReadme = readme.slice(0, start) + block + readme.slice(end);
  } else {
    // Append at end if markers missing
    newReadme = `${readme.trim()}\n\n${block}\n`;
  }

  if (newReadme !== readme) {
    fs.writeFileSync(README_PATH, newReadme, 'utf8');
    return true;
  }
  return false;
}

function coverageColor(pct) {
  const n = Number(pct);
  if (n >= 90) return 'brightgreen';
  if (n >= 80) return 'green';
  if (n >= 70) return 'yellowgreen';
  if (n >= 60) return 'yellow';
  if (n >= 50) return 'orange';
  return 'red';
}

function writeBadge(coverage) {
  if (!fs.existsSync(BADGES_DIR)) fs.mkdirSync(BADGES_DIR, { recursive: true });
  const msg = `${coverage.statements}%`;
  const color = coverageColor(coverage.statements);
  const payload = {
    schemaVersion: 1,
    label: 'coverage',
    message: msg,
    color,
  };
  fs.writeFileSync(BADGE_PATH, JSON.stringify(payload), 'utf8');
}

function main() {
  const cov = readCoverage();
  const changed = updateReadme(cov);
  writeBadge(cov);
  console.log(`Updated README coverage: ${changed ? 'changed' : 'no changes needed'}`);
}

if (require.main === module) {
  try {
    main();
  } catch (err) {
    console.error(err.message || err);
    process.exit(1);
  }
}
